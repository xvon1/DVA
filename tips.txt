
https://www.ncbi.nlm.nih.gov/geo/

<<<<<<< HEAD
:
============================Mac==========================
command not found :看source ~/.bash_profile是否有问题
(1)将/usr/udt中的所有文件移到当前目录(用”.”表示)中：
$ mv /usr/udt/* .
(2)将文件test.txt重命名为wbk.txt：
$ mv test.txt wbk.txt
Mac终端配置
export CLICOLOR=1
export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '
放～把这段代码放到 主目录的 .bash_profile 里，然后 source ~/.bash_profile
========================git command========================
git init
git add
git commit
git remote add origin https://git.coding.net/用户名/项目名.git
git push origin master
git reset --hard a2a514
git reset --hard HEAD^

==============================cancer and sex===============
=======
mac下执行gt操作或者make编译时，可能会出现如下错误：
xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun
可能是由于xcode问题造成的，可在终端中执行如下命令：
xcode-select --install
系统弹出下载xcode相关插件，大概1分钟安装完毕

-----------------------------------------------------------
>>>>>>> a003f4ef51702f53e4bcba0b9d5e1e2e3d2c20a4
> length(which(PhenoTypesLIHC.lv$cancer==0))
[1] 50
> length(which(PhenoTypesLIHC.lv$cancer==1))
[1] 349
> length(which(PhenoTypesLIHC.lv$gender==1))
[1] 263
> length(which(PhenoTypesLIHC.lv$gender==0))
[1] 136
==============================DVA===========================
> corrDVA<-realDVA$sortcorre
> View(corrDVA)
> corrDVA[1,]
    Sex        Race       Age       Cancer
[1] 0.85075485 0.09908821 0.25775275 0.28758518
> corrDVAIX<-realDVA$sortcorreIX
> corrDVAIX[1,]
[1] 10  8  9 15
P不能用sort的 由corrDVAIX找corrDVAIX、dvaFstat[c,f]
dvapv<-realDVA$pv
dvapv[10,] [1] 4.427070e-128
dvapv[9,] 2.619922e-08
dvapv[8,]
0.035001813
> corrSVA<-realSVA$sortcorre
> View(corrSVA)
> corrSVA[1,]
[1] 0.09851819 0.01459026 0.13169701 0.01787345
> corrSVAIX<-realSVA$sortcorreIX
> corrSVAIX[1,]
[1] 2 2 2 2
svapv<-realSVA$pv
svapv[2,]
[1] 0.036068933 0.756793147 0.004992677 0.704395228


----------------------------------------------------------------
CvMat，Mat和IplImage之间的转化和拷贝 
1,CvMat之间的复制
//注意：深拷贝 - 单独分配空间，两者相互独立  
CvMat* a;
CvMat* b = cvCloneMat(a);   //copy a to b  
2、Mat之间的复制
//注意：浅拷贝 -  不复制数据只创建矩阵头，数据共享（更改a,b,c的任意一个都会对另外2个产生同样的作用）
Mat a;
Mat b = a; //a "copy" to b
Mat c(a); //a "copy" to c

//注意：深拷贝
Mat a;
Mat b = a.clone(); //a copy to b
Mat c;
a.copyTo(c); //a copy to c

3、CvMat转Mat
//使用Mat的构造函数：Mat::Mat(const CvMat* m, bool copyData=false);    默认情况下copyData为false
CvMat* a;
//注意：以下三种效果一致，均为浅拷贝
Mat b(a);    //a "copy" to b
Mat b(a, false);    //a "copy" to b
Mat b = a;    //a "copy" to b

//注意：当将参数copyData设为true后，则为深拷贝（复制整个图像数据）
Mat b = Mat(a, true); //a copy to b

4、Mat转CvMat

//注意：浅拷贝
Mat a;
CvMat b = a; //a "copy" to b

//注意：深拷贝
Mat a;
CvMat *b;
CvMat temp = a; //转化为CvMat类型，而不是复制数据
cvCopy(&temp, b); //真正复制数据 cvCopy使用前要先开辟内存空间

==========IplImage与上述二者间的转化和拷贝===========
1、IplImage之间的复制
这个不赘述了，就是cvCopy与cvCloneImage使用区别，贴张网上的图：

2、IplImage转Mat
//使用Mat的构造函数：Mat::Mat(const IplImage* img, bool copyData=false);    默认情况下copyData为false
IplImage* srcImg = cvLoadImage("Lena.jpg");
//注意：以下三种效果一致，均为浅拷贝
Mat M(srcImg);
Mat M(srcImg, false);
Mat M = srcImg;
//注意：当将参数copyData设为true后，则为深拷贝（复制整个图像数据）
Mat M(srcImg, true);

3、Mat转IplImage
//注意：浅拷贝 - 同样只是创建图像头，而没有复制数据
Mat M;
IplImage img = M;
IplImage img = IplImage(M);
//深拷贝
cv::Mat img2;
IplImage imgTmp = img2;
IplImage *input = cvCloneImage(&imgTmp);

4、IplImage转CvMat
//法一：cvGetMat函数
IplImage* img;
CvMat temp;
CvMat* mat = cvGetMat(img, &temp);    //深拷贝
//法二：cvConvert函数
CvMat *mat = cvCreateMat(img->height, img->width, CV_64FC3);    //注意height和width的顺序
cvConvert(img, mat);    //深拷贝

5、CvMat转IplImage

//法一：cvGetImage函数
CvMat M;
IplImage* img = cvCreateImageHeader(M.size(), M.depth(), M.channels());
cvGetImage(&M, img);    //深拷贝：函数返回img
//也可写成
CvMat M;
IplImage* img = cvGetImage(&M, cvCreateImageHeader(M.size(), M.depth(), M.channels()));
//法二：cvConvert函数
CvMat M;
IplImage* img = cvCreateImage(M.size(), M.depth(), M.channels());
cvConvert(&M, img);    //深拷贝
======================================宏=================

#if defined __DRAW_IMPL__
	#if (defined _AFXDLL && !defined __STAT_WITH_DLLMFC__)
		#define __DRAW_API _declspec(dllexport)
	#else
		#define __DRAW_API
	#endif // _AFXDLL
#else 
	#if (defined _AFXDLL && !defined __STAT_WITH_DLLMFC__)
		#define __DRAW_API _declspec(dllimport)
	#else
		#define __DRAW_API
	#endif // _AFXDLL

	#pragma message("      (Professional User Interface Suite)")
	#pragma comment( lib, __DRAW_LIB_NAME ) 
#endif
一般在编写动态链接库里的类时，经常会定义象上面的宏，主要是为了使用方便，这样在编写库时，只要定义了__DRAW_IMPL__宏，所有动态库中的类都会自动导出，
例如：class __DRAW_API A{};编译时会被展开成calss _declspec(dllexport) A{};
而在用户使用时，因为没有定义__DRAW_IMPL__宏，所有的类自动加上dllimport成为导入类,成为class _declspec(import).
如果静态链接时或者直接使用时，只要定义了__STAT_WITH_DLLMFC__宏，相当于直接定义类,__DRAW_API被展开成空串.
。宏定义是C提供的三种预处理功能的其中一种，这三种预处理包括：宏定义、文件包含、条件编译
